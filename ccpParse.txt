import pandas as pd
import xml.etree.ElementTree as ET

# Placeholder for allowed classifications under domain 'CLMFO'
allowed_clmfo_classifications = [
    # Add your allowed classification strings here
    "EXAMPLE1",
    "EXAMPLE2",
    "EXAMPLE3"
]

# List to collect parsed rows
parsed_rows = []

def parse_org_business_classes():
    for idx, row in df_CCP.iterrows():
        xml_content = row['orgBusinessClasses']

        if not xml_content or pd.isna(xml_content):
            continue

        try:
            root = ET.fromstring(f"<root>{xml_content}</root>")
        except ET.ParseError:
            continue

        for business_class in root.findall(".//businessClass"):
            domain = business_class.findtext("domain", default="").strip()
            classification = business_class.findtext("classification", default="").strip()
            classification_desc = business_class.findtext("classificationDesc", default="").strip()
            parent_classification_code = business_class.findtext("parentClassificationCode", default="").strip()
            parent_classification = business_class.findtext("parentClassification", default="").strip()

            if domain in ["CLMPR", "KYDNT", "ACCA"]:
                parsed_rows.append({
                    "domain": domain,
                    "classification": classification,
                    "classificationDesc": classification_desc,
                    "parentClassificationCode": parent_classification_code,
                    "parentClassification": parent_classification
                })
            elif domain == "CLMFO" and classification in allowed_clmfo_classifications:
                parsed_rows.append({
                    "domain": domain,
                    "classification": classification,
                    "classificationDesc": classification_desc,
                    "parentClassificationCode": parent_classification_code,
                    "parentClassification": parent_classification
                })
            else:
                continue

# Execute parsing
parse_org_business_classes()

# List of final column names
final_columns = ['domain', 'classification', 'classificationDesc', 'parentClassificationCode', 'parentClassification']

# Create parsed DataFrame, ensuring columns exist even if empty
df_CCP_Parsed = pd.DataFrame(parsed_rows, columns=final_columns)

# Force string type
for col in final_columns:
    df_CCP_Parsed[col] = df_CCP_Parsed[col].astype(str)

# Output
Alteryx.write(df_CCP_Parsed, 1)
Alteryx.write(df_CCP_Parsed, 1)
